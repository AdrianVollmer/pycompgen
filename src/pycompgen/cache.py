import os
from pathlib import Path
from typing import List

from .models import GeneratedCompletion, Shell
from .logger import get_logger


def get_cache_dir() -> Path:
    """Get the cache directory for completions."""
    # Use XDG_CACHE_HOME if set, otherwise use ~/.cache
    cache_home = os.environ.get("XDG_CACHE_HOME")
    if cache_home:
        cache_dir = Path(cache_home) / "pycompgen"
    else:
        cache_dir = Path.home() / ".cache" / "pycompgen"

    # Create directory if it doesn't exist
    cache_dir.mkdir(parents=True, exist_ok=True)
    return cache_dir


def save_completions(
    completions: List[GeneratedCompletion], cache_dir: Path, force: bool = False
) -> None:
    """Save completions to cache directory."""
    logger = get_logger()
    cache_dir.mkdir(parents=True, exist_ok=True)

    for completion in completions:
        save_completion(completion, cache_dir, force)

    logger.info(f"Saved {len(completions)} completion files to {cache_dir}")


def save_completion(
    completion: GeneratedCompletion, cache_dir: Path, force: bool = False
) -> None:
    """Save a single completion to cache."""
    # Create filename based on package name and shell
    filename = f"{completion.package_name}.{completion.shell.value}.sh"
    filepath = cache_dir / filename

    # Check if file exists and force is not set
    if filepath.exists() and not force:
        # Don't overwrite existing files unless forced
        return

    # Write the completion content
    try:
        filepath.write_text(completion.content)
    except OSError as e:
        raise RuntimeError(f"Failed to write completion file {filepath}: {e}")


def get_completion_files(cache_dir: Path) -> List[Path]:
    """Get all completion files in the cache directory."""
    if not cache_dir.exists():
        return []

    return [f for f in cache_dir.glob("*.sh") if f.is_file()]


def clean_cache(cache_dir: Path, keep_packages: List[str]) -> None:
    """Clean cache directory, removing completions for packages not in keep_packages."""
    if not cache_dir.exists():
        return

    # Include both shell variations
    keep_files = set()
    for package in keep_packages:
        for shell in Shell:
            keep_files.add(f"{package}.{shell.value}.sh")

    for filepath in cache_dir.glob("*.sh"):
        if filepath.name not in keep_files and filepath.name != "completions.sh":
            try:
                filepath.unlink()
            except OSError:
                pass  # Ignore errors when removing files


def generate_source_script(cache_dir: Path) -> str:
    """Generate a script that sources appropriate completion files based on shell."""
    completion_files = get_completion_files(cache_dir)
    
    # Group files by shell
    bash_files = []
    zsh_files = []
    
    for filepath in completion_files:
        if filepath.name.endswith('.bash.sh'):
            bash_files.append(filepath)
        elif filepath.name.endswith('.zsh.sh'):
            zsh_files.append(filepath)

    script_lines = ["#!/bin/bash"]
    script_lines.append("# Generated by pycompgen")
    script_lines.append("# This file sources shell-appropriate completion scripts")
    script_lines.append("")
    script_lines.append("# Detect current shell")
    script_lines.append('current_shell="$(basename "${SHELL:-bash}")"')
    script_lines.append("")
    
    if bash_files or zsh_files:
        script_lines.append("case \"$current_shell\" in")
        
        if zsh_files:
            script_lines.append("    zsh)")
            for filepath in sorted(zsh_files):
                script_lines.append(f"        source {filepath}")
            script_lines.append("        ;;")
        
        if bash_files:
            script_lines.append("    bash|*)")
            for filepath in sorted(bash_files):
                script_lines.append(f"        source {filepath}")
            script_lines.append("        ;;")
        
        script_lines.append("esac")
        script_lines.append("")

    script_lines.append("# Add this to your shell config: source <path-to-this-file>")

    return "\n".join(script_lines)


def get_source_path(cache_dir: Path) -> Path:
    script_path = cache_dir / "completions.sh"
    return script_path


def save_source_script(cache_dir: Path) -> Path:
    """Save the source script to cache directory."""
    logger = get_logger()
    cache_dir.mkdir(parents=True, exist_ok=True)

    script_content = generate_source_script(cache_dir)
    script_path = get_source_path(cache_dir)

    try:
        script_path.write_text(script_content)
        logger.info(f"Created source script: {script_path}")
    except OSError as e:
        raise RuntimeError(f"Failed to write source script {script_path}: {e}")

    return script_path
